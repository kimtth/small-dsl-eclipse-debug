/*
 * generated by Xtext 2.12.0
 */
package org.xtext.labs.scoping

import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.xtext.labs.mydsl.FuncDefinition
import org.xtext.labs.mydsl.MydslPackage
import org.xtext.labs.mydsl.arrayRef
import org.xtext.labs.mydsl.mainDeclared
import org.xtext.labs.mydsl.varAssignment
import org.xtext.labs.mydsl.varDeclared
import org.xtext.labs.mydsl.varRef
import org.xtext.labs.mydsl.DSLProgram

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MydslScopeProvider extends AbstractMydslScopeProvider {

	val epackage = MydslPackage.eINSTANCE

	/**
	 * @Comment:kim 
	 * 	IResourceDescription is a meta-data about Eobject's scope information.
	 * 	IResourceDescription maybe like this. ex) func.innerfunc.var / func.var
	 * 	if IResourceDescription is not properly created, cross-reference not will work and return null.

	 * 	Especially indexing need to implement when you reference object across file.
	 * 	index is similar like a database about IResourceDescription,
	 * 	because memory is limited and doesn't need to load all of file in memory all the time.
	 * 	not implemented here. maybe further. 
	 * **/
	override getScope(EObject context, EReference reference) {
		if (reference == epackage.getvarRef_VarRef) {
			return scopeForSymbolRef(context)
		}
		if (reference == epackage.getarrayRef_VarRef) {
			return scopeForSymbolRef(context)
		}

		return super.getScope(context, reference)
	}

	/**
	 * @Comment:kim 
	 * this function try to find outer scope recursively. DSLProgram is end of traverse. 
	 */
	def protected IScope scopeForSymbolRef(EObject context) {
		val container = context.eContainer

		return switch (container) {
			FuncDefinition:
				Scopes.scopeFor(findScope(container), scopeForSymbolRef(container))
			mainDeclared:
				Scopes.scopeFor(findScopeMain(container), scopeForSymbolRef(container))
			DSLProgram:
				Scopes.scopeFor(container.global) // end of traverse. outer's default value is IScope.NULLSCOPE
			default:
				scopeForSymbolRef(container)
		}
	}

	def findScopeMain(mainDeclared declared) {
		var locals = new ArrayList();

		for (body : declared.body) {
			if (body instanceof varDeclared) {
				if (body.scope.equals("val")) {
					locals.add(body);
				}
			}
		}

		return locals
	}

	def findScope(FuncDefinition definition) {
		var locals = new ArrayList();

		for (body : definition.body) {
			if (body instanceof varDeclared) {
				if (body.scope.equals("val")) {
					locals.add(body);
				}
			}
		}

		for (arg : definition.args) {
			locals.add(arg);
		}
		return locals
	}

	def isDefinedBefore(varDeclared declared, FuncDefinition definition) {
		var isFlag = true
		val declaredName = declared.name

		for (body : definition.body) {
			if (body instanceof varAssignment) {
				var targetVarName = ""
				val lefte = body.left

				if (lefte instanceof varRef) {
					targetVarName = lefte.getVarRef().name
				} else if (lefte instanceof arrayRef) {
					targetVarName = lefte.getVarRef().name
				}

				// kim: check index of varAssginment whether before local variable declare.
				// if var assign before declare. it will be filtered. 
				if (declaredName == targetVarName) {
					if (definition.body.indexOf(declared) <= definition.body.indexOf(body)) {
						println(definition.body.indexOf(declared) + " : " + definition.body.indexOf(body))
						isFlag = false
						return isFlag
					}
				}
			}
		}

		return isFlag
	}

/**
 * @comment: kim
 * something not useful sample.
 *
 * 	def private variablesDeclaredBefore(List<SJStatement> list, EObject o) {
 * 		list.subList(0, list.indexOf(o)).filter(typeof(SJVariableDeclaration))
 * 	}
 * 	def IScope scope_local_varDeclared(FuncDefinition container, EReference reference) {

 * 		if (reference == MydslPackage.Literals.VAR_DECLARED) {
 * 			val localcandidate = EcoreUtil2.getAllContentsOfType(container, varDeclared);
 * 			var locals = new ArrayList();

 * 			for (local : localcandidate) {
 * 				if (local.scope.equals("val")) {
 * 					locals.add(local);
 * 				}
 * 			}
 * 			return Scopes.scopeFor(locals);
 * 		}
 * 	}
 * 	def boolean isSub(EObject eObject) {
 * 		var result = false;
 * 		if (eObject !== null) {
 * 			for (var parent = eObject.eContainer(); parent !== null; parent = parent.eContainer()) {
 * 				if (parent instanceof FuncCall) {
 * 					result = true
 * 					return result
 * 				} else {
 * 					isSub(parent);
 * 				}
 * 			}
 * 		}
 * 		return result;
 * 	}
 *  val rootElement = EcoreUtil2.getRootContainer(context)
 */
}
