/*
 * generated by Xtext 2.11.0
 */
package org.xtext.labs.generator

import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.xtext.labs.mydsl.AbstractMethodCall
import org.xtext.labs.mydsl.BodyStatement
import org.xtext.labs.mydsl.BrkStr
import org.xtext.labs.mydsl.DSLProgram
import org.xtext.labs.mydsl.DoWhileExpression
import org.xtext.labs.mydsl.FuncCall
import org.xtext.labs.mydsl.FuncDefinition
import org.xtext.labs.mydsl.FuncParameter
import org.xtext.labs.mydsl.IfExpression
import org.xtext.labs.mydsl.StdFunction
import org.xtext.labs.mydsl.StringRef
import org.xtext.labs.mydsl.Terminal
import org.xtext.labs.mydsl.arrayRef
import org.xtext.labs.mydsl.numRef
import org.xtext.labs.mydsl.varAssignment
import org.xtext.labs.mydsl.varDeclared
import org.xtext.labs.mydsl.varExpression
import org.xtext.labs.mydsl.varRef
import org.xtext.labs.mydsl.boolRef
import org.xtext.labs.mydsl.varReturn

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MydslGeneratorCS {

	/**@comment:kim
	 * cs version is only for testing, maybe for fun -.-;; .
	 * when you want to launch dsl as a call by reference language like a pascal.
	 * or your language just support call by reference only.
	 * so every function parameter will be attached ref keyword.
	 */
	def compileCsharp(DSLProgram dsl, String fileName) {
		'''
			using System;
			using System.Collections.Generic;
			
			/**
			*
			this c# file is generated from «toTitleCase(fileName)».dsl. the generator was written by kim.
			*/
			
			namespace «fileName.replace("-","")»{
				class Program{
					
					static Dictionary<string, string> map = new Dictionary<string, string>();
					
					«IF dsl.global !== null»
						«FOR param : dsl.global» 
							«compilevarDeclaredGlobal(param)»
						«ENDFOR»
					«ENDIF»
					
					«FOR func : dsl.func»
						private static «rtnType(func)» «func.name»(«compileArgDeclaration2(func.args)»){
						«FOR body : func.body»						
							«compileBodyStatement(body)»
						«ENDFOR»
						}
					«ENDFOR»				
			
					public static void Main(string[] args){
						init(args);
						
						//Program Area
					«FOR body : dsl.main.body»
						«compileBodyStatement(body)»
				«ENDFOR»
						
						Console.ReadLine(); //for blocking C# console applications closing automatically.
					}
			
				«stdfunctionModelBuilder»
				}
			}
			
		'''
	}

	def rtnType(FuncDefinition d) {
		var buf = "void"

		for (p : d.body) {
			if (p instanceof varReturn) {
				val t = TerminalResolver(p.rtn)
				buf = typeName(t)
			}
		}

		return buf
	}

	def TerminalResolver(Terminal t) {
		var buf = ""

		if (t instanceof varRef) {
			val sb = t.varRef
			buf = sb.type
		}

		if (t instanceof arrayRef) {
			val sb = t.varRef
			buf = sb.type
		}

		return buf
	}

	def compilevarDeclaredGlobal(varDeclared p) {
		var buf = "static "

		buf += compilevarDeclared(p)

		return buf
	}

	def compileArgDeclaration2(EList<FuncParameter> pl) {
		var buf = ""

		for (p : pl) {
			buf += typeName(p.type)
			buf += " " + p.name

			if (pl.length != (pl.lastIndexOf(p) + 1)) {
				buf += ','
			}
		}

		return buf
	}

	def compileArgDeclaration(EList<varDeclared> pl) {
		var buf = ""

		for (p : pl) {
			buf += "ref " + typeName(p.type)

			for (d : p.dim) {
				var isLast = false

				if (p.dim.length == (p.dim.lastIndexOf(d) + 1)) {
					isLast = true
				}

				if (0 == p.dim.indexOf(d)) {
					buf += "["
				}
				if (!isLast) {
					buf += ","
				}
				if (isLast) {
					buf += ']'
				}
			}

			buf += " " + p.name

			if (pl.length != (pl.lastIndexOf(p) + 1)) {
				buf += ','
			}
		}

		return buf
	}

	def compilevarDeclared(varDeclared p) {
		var buf = ""
		var isDim = false

		buf = typeName(p.type)

		// Multidimensional Array [][] vs [,]
		// http://stackoverflow.com/questions/12567329/multidimensional-array-vs
		// double[,] ServicePoint = new double[10,9];
		// ServicePoint[0][2]
		// array index to be int
		if (p.dim.length != 0) {
			isDim = true

			for (d : p.dim) {
				var isLast = false
				if (p.dim.length == (p.dim.lastIndexOf(d) + 1)) {
					isLast = true
				}

				if (0 == p.dim.indexOf(d)) {
					buf += "["
				}
				if (!isLast) {
					buf += ","
				}
				if (isLast) {
					buf += ']'
				}
			}

			buf += ''' «p.name»'''
			buf += " = new "
			buf += typeName(p.type)

			for (d : p.dim) {
				var isLast = false
				if (p.dim.length == (p.dim.lastIndexOf(d) + 1)) {
					isLast = true
				}

				if (0 == p.dim.indexOf(d)) {
					buf += "["
				}
				buf += d.size.toString
				if (!isLast) {
					buf += ","
				}
				if (isLast) {
					buf += '];'
				}
			}
		}

		if (!isDim) {
			buf += ''' «p.name»'''
			if (p.type == "string") {
				buf += " = \"\";"
			} else {
				buf += " = 0;"
			}
		}

		return buf
	}

	def compileBodyStatement(BodyStatement b) {
		switch (b) {
			varExpression: compilevarExpression(b)
			IfExpression: compileIfExpression(b)
			DoWhileExpression: compileDoWhileExpression(b)
			BrkStr: brkStr(b)
			AbstractMethodCall: compileAbstractMethod(b)
		}
	}

	def compilevarExpression(varExpression r) {
		var buf = new StringBuilder()

		if (r instanceof varAssignment) {
			buf.append(TerminalMatchFinder(r.left))

			for (op : r.op) {
				var opStr = op

				if (op.equals("and")) {
					opStr = '&'
				} else if (op.equals("or")) {
					opStr = '|'
				}

				buf.append(" " + opStr + " ")

				val a = r.right.get(r.op.indexOf(op))

				if (a instanceof Terminal) {
					buf.append(TerminalMatchFinder(a))
				} else if (a instanceof AbstractMethodCall) {
//					if (a instanceof FuncCall) {
//						buf.append(compileFuncCall(a))
//					}
					var func = compileAbstractMethod(a)
					if (r.eContainer instanceof IfExpression) {
						func = func.replace(";", "")
					}
					buf.append(func)
				}

			}
		}

		if (isColon(r)) {
			buf.append(";")
		}

		return buf.toString.replace(";;", ";")
	}

	def TerminalMatchFinder(Terminal t) {
		var buf = ""

		if (t instanceof numRef) {
			buf = t.value.toString()
		}
		if (t instanceof arrayRef) {
			buf = t.varRef.name

			for (d : t.dim) {
				var isLast = false
				if (t.dim.length == (t.dim.lastIndexOf(d) + 1)) {
					isLast = true
				}

				if (0 == t.dim.indexOf(d)) {
					buf += "["
				}

				if (d.index !== null) {
					buf += d.index.name
				} else {
					buf += d.size.toString
				}

				if (!isLast) {
					buf += ','
				}
				if (isLast) {
					buf += ']'
				}
			}
		}
		if (t instanceof varRef) {
			buf = t.varRef.name
		}

		if (t instanceof StringRef) {
			buf = '\"' + t.value + '\"'
		}
		if (t instanceof boolRef) {
			buf = t.varRef
		}

		return buf
	}

	def compileAbstractMethod(AbstractMethodCall r) {
		switch (r) {
			FuncCall: compileFuncCall(r)
			StdFunction: compileStdFunction(r)
		}
	}

	def String compileFuncCall(FuncCall s) {
		var buf = ""
		buf = '''«funcName(s)»('''

		for (p : s.args) {
			if (p instanceof varRef) {
				buf += "ref " + p.varRef.name

				if (s.args.length != (s.args.lastIndexOf(p) + 1)) {
					buf += ','
				}
			}
		// Is it need to develop for ArrayRef? 
		}
		buf += ')'

		if (isColon(s)) {
			buf += ";"
		}

		return buf
	}

	def compileStdFunction(StdFunction s) {
		var buf = ""
		buf = '''«s.name»('''

		for (p : s.args) {
			if (p instanceof varRef) {
				buf += p.varRef.name
			}

			if (p instanceof StringRef) {
				buf += "\"" + p.value + "\""
			}

			if (p instanceof numRef) {
				buf += p.value.toString
			}

			if (p instanceof boolRef) {
				buf += p.varRef
			}

			if (s.args.length != (s.args.lastIndexOf(p) + 1)) {
				buf += ','
			}
		// Is it need to develop for ArrayRef? 
		}
		buf += ')'

		if (isColon(s)) {
			buf += ";"
		}

		return buf
	}

	def compileIfExpression(IfExpression r) {
		val buf = new StringBuilder()

		buf.append("if(")
		buf.append(compilevarExpression(r.ifconditon))
		buf.append("){\n")
		for (t : r.then) {
			buf.append(compileBodyStatement(t))
		}

		if (r.^else.length !== 0) {
			buf.append("}else{\n")
			for (t : r.^else) {
				buf.append(compileBodyStatement(t))
			}
		}

		buf.append("}\n")

		return buf.toString
	}

	def compileDoWhileExpression(DoWhileExpression r) {
		val buf = new StringBuilder()

		buf.append("while(")
		buf.append(compilevarExpression(r.loopConditon))
		buf.append("){\n")

		for (t : r.body) {
			buf.append(compileBodyStatement(t))
		}

		buf.append("}\n")

		return buf.toString
	}

	/**
	 * Util Area
	 */
	def funcName(FuncCall s) {
		val funcCrossRef = s.func
		var funcname = funcCrossRef.name
		return funcname
	}

	def String typeName(String s) {
		var buf = ""
		switch (s) {
			case "num": buf = '''int'''
			case "bool": buf = '''bool'''
			case "string": buf = '''string'''
		}
		return buf
	}

	def String brkStr(BrkStr r) {
		"break;"
	}

	def Boolean isColon(EObject s) {
		var isColon = true

		if (s.eContainer instanceof IfExpression || s.eContainer instanceof DoWhileExpression ||
			s.eContainer instanceof varAssignment) {
			if (s.eContainingFeature.name.equals("ifconditon") || s.eContainingFeature.name.equals("loopConditon")) {
				isColon = false
			}
			if (s.eContainer.eContainer instanceof IfExpression ||
				s.eContainer.eContainer instanceof DoWhileExpression) {
				if (s.eContainer.eContainingFeature.name.equals("ifconditon") ||
					s.eContainer.eContainingFeature.name.equals("loopConditon")) {
					isColon = false
				}
			}
		}
		return isColon
	}

	def String toTitleCase(String input) {
		val titleCase = new StringBuilder()
		var isFirst = true

		for (c : input.toCharArray()) {
			var ch = c
			if (isFirst) {
				ch = Character.toTitleCase(ch);
				isFirst = false;
			} else {
				ch = Character.toLowerCase(ch);
			}

			titleCase.append(ch);
		}
		return titleCase.toString();
	}

	def String stdfunctionModelBuilder() {
		val buf = new StringBuilder()

		buf.append("\n//Standard Function ======================================================\n")
		buf.append("private static void printstr(String a){ Console.WriteLine(a); }\n")
		buf.append("private static String strjoin(String a, String b){ a = string.Concat(a,b); return a; }\n")
		buf.append("private static String[] strsplit(String a, String b){ String[] rtn = a.Split(b); return rtn; }\n")
		buf.append("private static String numtostr(int a){ String rtn = a.ToString(); return rtn; }\n")

		// c# long is internally represented as System.Int64 which is a 64-bit signed integer.
		// main String arg[] to Map 
		buf.append("private static void init(string[] args){\n\tforeach (string arg in args){\n")
		buf.append("\t\tstring[] ag = arg.Split('/');\n\t\tmap.Add(ag[0], ag[1]);\t\n}\n}\n")

		return buf.toString()
	}

}
