/*
 * generated by Xtext 2.12.0
 */
package org.xtext.labs.validation

import com.google.inject.Inject
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check
import org.xtext.labs.mydsl.BrkStr
import org.xtext.labs.mydsl.DoWhileExpression
import org.xtext.labs.mydsl.FuncCall
import org.xtext.labs.mydsl.FuncDefinition
import org.xtext.labs.mydsl.IfExpression
import org.xtext.labs.mydsl.MydslPackage
import org.xtext.labs.mydsl.StdFunction
import org.xtext.labs.mydsl.StringRef
import org.xtext.labs.mydsl.Terminal
import org.xtext.labs.mydsl.arrayDimension
import org.xtext.labs.mydsl.arrayRef
import org.xtext.labs.mydsl.numRef
import org.xtext.labs.mydsl.varAssignment
import org.xtext.labs.mydsl.varDeclared
import org.xtext.labs.mydsl.varExpression
import org.xtext.labs.mydsl.varRef
import org.xtext.labs.typing.MydslTypeProvider
import org.xtext.labs.mydsl.FuncParameter

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MydslValidator extends AbstractMydslValidator {

	@Inject extension MydslTypeProvider

	public static val INVALID_NAME = 'uppercase_only'
	public static val INVALID_DUPLICATE = 'is_duplicate'
	public static val INVALID_FUNCTION_DUPLICATE = 'is_fucntion_duplicate'
	public static val INVALID_BREAK = 'not_valid_break'
	public static val INVALID_TYPES = 'not_valid_type'
	
	/**
	 * @comment:kim
	 * this is not best implementation, need to improving
	 */
	@Check
	def checkBreakStr(BrkStr brk) {
		var isTarget = true
		if (brk.eContainer instanceof IfExpression) {
			isTarget = false
		}

		if (isTarget) {
			error('The Break Statement is not inside If condition.', MydslPackage.Literals.BRK_STR__BRK, INVALID_BREAK)
		}
	}

	@Check
	def checkDuplicateVar(varDeclared check) {
		var mapping_cnt = 0
		for (itemto : check.eContainer.eContents) {
			if (itemto instanceof varDeclared) {
				if (check.name.equalsIgnoreCase(itemto.name)) {
					mapping_cnt += 1
				}
			}
		}

		if (mapping_cnt > 1) {
			error('The Variable must be not duplicated.', MydslPackage.Literals.VAR_SYMBOL__NAME, INVALID_DUPLICATE)
		}
	}

	@Check
	def checkDuplicateFuncName(FuncDefinition check) {
		var mapping_cnt = 0
		for (itemto : check.eContainer.eContents) {
			if (itemto instanceof FuncDefinition) {
				if (check.name.equalsIgnoreCase(itemto.name)) {
					mapping_cnt += 1
				}
			}
		}

		if (mapping_cnt > 1) {
			error('The Function name must be not duplicated.', MydslPackage.Literals.FUNC_DEFINITION__NAME,
				INVALID_FUNCTION_DUPLICATE)
		}
	}

	@Check
	def void checkCompatibleTypes(varExpression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType

		if (expectedType === null || actualType === null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Incompatible types. This variable could not assign to " + expectedType + " Type.", null,
				INVALID_TYPES);
		}
	}

	@Check
	def oper_ifOrLoopcheck(varAssignment vas) {
		var isConditionOp = false
		var isTarget = false
		if (vas.eContainer instanceof IfExpression || vas.eContainer instanceof DoWhileExpression) {
			if (vas.eContainingFeature.name.equals("ifconditon") ||
				vas.eContainingFeature.name.equals("loopConditon")) {
				isTarget = true

				for (op : vas.op) {
					if (op.equals(">=") || op.equals("<=") || op.equals("==") || op.equals("!=") || op.equals("<") ||
						op.equals(">")|| op.equals("and") || op.equals("or")) {
						isConditionOp = true
						return
					}
				}
			}
		}

		if (isTarget && !isConditionOp) {
			error("Incompatible Operation. The operation should be condition.(>=,<=,==,!=,<,>)", null);
		}

		if (vas.op.size > 2) {
			error("Not allowed multiple operation in Right Assignment", null)
		}
	}

	@Check
	def checkArrayInDataArea(arrayDimension ar) {
		if (ar.eContainer instanceof varDeclared) {
			if (ar.index !== null) {
				error("Array Index should be NUM.", null);
			}

			// BigDecimal to Integer
			if (Integer.valueOf(ar.size.intValue()) < 1) {
				error("Array Size should be more than number 1.", null);
			}
		}
	}

	@Check
	def checkArrayDimension(arrayRef ar) {
		
		val arRef = ar.varRef
		var arlen = 0
		if(arRef instanceof varDeclared){
			arlen = arRef.dim.length
		}
		
		//kim: if arRef is a FuncParameter, this token will be exclude as a target of validation. just skip.
		if(arRef instanceof FuncParameter){
			arlen = ar.dim.length
		}
		
		if (ar.dim.length != arlen) {
			val size = arlen//ar.varRef?.dim.length
			error("Array Dimension Size is Incompatible. Dimension Size is " + size.toString + ".", null);
		}

		if (ar.dim.size < 1) {
			error("Array Size should be more than number 1.", null);
		}
	}

	@Check
	def checkStdFuctionArgSize(StdFunction std) {
		val args = std.args.length
		val dfi = getStdDefinition(std.name)
		val defargs = dfi.toCharArray.size

		if (defargs !== args) {
			error("Standard Function arguments size is incompatible. \nThe arguments size is " + defargs.toString + ".",
				null);
		} else {
			val errormsg = stdArgsTypeCompare(std.args, dfi)
			if (!errormsg.empty) {
				error("Standard Function arguments type is incompatible.\n" + errormsg, null);
			}
		}
	}

	def stdArgsTypeCompare(EList<Terminal> inputarg, String dfi) {
		val dfarr = dfi.toCharArray
		var errormsg = new StringBuilder()
		var i = 0

		for (ia : dfarr) {
			var type = ""
			switch ia.toString {
				case "N": type = "num"
				case "S": type = "string"
				case "O": type = "number or string or bool"
			}

			val itm = inputarg.get(i)
			val tyitm = typeReturn(itm)
			if (!type.toString.equals(tyitm)) {
				if (!(type.toString == "O" && (tyitm.contains("num")))) {
					if (containsDigit(type.toString, tyitm) == false) {
						if (type.equals("O")) {
							type = "Number or String or Bool" // for Message
						}
						errormsg.append((i + 1).toString + ": " + type + "\n")
					}
				}
			}
			i += 1
		}

		return errormsg.toString
	}

	def containsDigit(String a, String b) {
		var hasDigit = false

		if (a.equals("num") && b.equals("num")) {
			hasDigit = true
		}

		return hasDigit
	}

	@Check
	def checkFuncArgSize(FuncCall sub) {
		val args = sub.args.length
		var sizearg = sub.func.args.size
		val sf = sub.func

		if (sizearg !== args) {
			error("function arguments size is incompatible. function's arguments size is " + sizearg.toString + ".", null);
		} else {
			val errormsg = argsTypeCompare(sf, sub.args)
			if (!errormsg.empty) {
				error("function arguments type is incompatible.\n" + errormsg, null);
			}
		}
	}

	def argsTypeCompare(FuncDefinition defarg, EList<Terminal> callarg) {
		var errormsg = new StringBuilder()
		val dg = defarg.args

		for (item : dg) {

			if (item instanceof arrayRef) {
				val i = dg.indexOf(item)
				if (item.varRef.type != typeReturn(callarg.get(i))) {
					if (containsDigit(item.varRef.type, typeReturn(callarg.get(i))) == false) {
						errormsg.append((i + 1).toString + ": " + item.toString + "\n")
					}
				}
			}
			
			if(item instanceof varRef){
				val i = dg.indexOf(item)
				if (item.varRef.type != typeReturn(callarg.get(i))) {
					if (containsDigit(item.varRef.type, typeReturn(callarg.get(i))) == false) {
						errormsg.append((i + 1).toString + ": " + item.toString + "\n")
					}
				}
			}
		}

		return errormsg.toString
	}

	def String typeReturn(Terminal t) {
		var rtn = ""
		switch (t) {
			numRef: rtn = "num"
			StringRef: rtn = "string"
			arrayRef: rtn = t.varRef?.type
			varRef: rtn = t.varRef?.type
		}
		return rtn
	}

	def tryParseInt(String value) {
		try {
			Integer.parseInt(value);
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}

	def getStdDefinition(String d) {
		var buff = ""
		switch d {
			case "printstr": buff = "S"
			case "strjoin": buff = "SS"
			case "strsplit": buff = "SS"
			case "numtostr": buff = "N"
			case "equals": buff = "OO" // num or string or bool
			case "getargs" : buff = "N"
		}
		return buff
	}
}
