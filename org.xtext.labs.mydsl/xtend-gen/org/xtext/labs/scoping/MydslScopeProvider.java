/**
 * generated by Xtext 2.12.0
 */
package org.xtext.labs.scoping;

import com.google.common.base.Objects;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.xtext.labs.mydsl.BodyStatement;
import org.xtext.labs.mydsl.DSLProgram;
import org.xtext.labs.mydsl.FuncDefinition;
import org.xtext.labs.mydsl.FuncParameter;
import org.xtext.labs.mydsl.MydslPackage;
import org.xtext.labs.mydsl.Terminal;
import org.xtext.labs.mydsl.arrayRef;
import org.xtext.labs.mydsl.mainDeclared;
import org.xtext.labs.mydsl.varAssignment;
import org.xtext.labs.mydsl.varDeclared;
import org.xtext.labs.mydsl.varRef;
import org.xtext.labs.mydsl.varSymbol;
import org.xtext.labs.scoping.AbstractMydslScopeProvider;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class MydslScopeProvider extends AbstractMydslScopeProvider {
  private final MydslPackage epackage = MydslPackage.eINSTANCE;
  
  /**
   * @Comment:kim
   * 	IResourceDescription is a meta-data about Eobject's scope information.
   * 	IResourceDescription maybe like this. ex) func.innerfunc.var / func.var
   * 	if IResourceDescription is not properly created, cross-reference not will work and return null.
   * 
   * 	Especially indexing need to implement when you reference object across file.
   * 	index is similar like a database about IResourceDescription,
   * 	because memory is limited and doesn't need to load all of file in memory all the time.
   * 	not implemented here. maybe further.
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    EReference _varRef_VarRef = this.epackage.getvarRef_VarRef();
    boolean _equals = Objects.equal(reference, _varRef_VarRef);
    if (_equals) {
      return this.scopeForSymbolRef(context);
    }
    EReference _arrayRef_VarRef = this.epackage.getarrayRef_VarRef();
    boolean _equals_1 = Objects.equal(reference, _arrayRef_VarRef);
    if (_equals_1) {
      return this.scopeForSymbolRef(context);
    }
    return super.getScope(context, reference);
  }
  
  /**
   * @Comment:kim
   * this function try to find outer scope recursively. DSLProgram is end of traverse.
   */
  protected IScope scopeForSymbolRef(final EObject context) {
    final EObject container = context.eContainer();
    IScope _switchResult = null;
    boolean _matched = false;
    if (container instanceof FuncDefinition) {
      _matched=true;
      _switchResult = Scopes.scopeFor(this.findScope(((FuncDefinition)container)), this.scopeForSymbolRef(container));
    }
    if (!_matched) {
      if (container instanceof mainDeclared) {
        _matched=true;
        _switchResult = Scopes.scopeFor(this.findScopeMain(((mainDeclared)container)), this.scopeForSymbolRef(container));
      }
    }
    if (!_matched) {
      if (container instanceof DSLProgram) {
        _matched=true;
        _switchResult = Scopes.scopeFor(((DSLProgram)container).getGlobal());
      }
    }
    if (!_matched) {
      _switchResult = this.scopeForSymbolRef(container);
    }
    return _switchResult;
  }
  
  public ArrayList<varDeclared> findScopeMain(final mainDeclared declared) {
    ArrayList<varDeclared> locals = new ArrayList<varDeclared>();
    EList<BodyStatement> _body = declared.getBody();
    for (final BodyStatement body : _body) {
      if ((body instanceof varDeclared)) {
        boolean _equals = ((varDeclared)body).getScope().equals("val");
        if (_equals) {
          locals.add(((varDeclared)body));
        }
      }
    }
    return locals;
  }
  
  public ArrayList<varSymbol> findScope(final FuncDefinition definition) {
    ArrayList<varSymbol> locals = new ArrayList<varSymbol>();
    EList<BodyStatement> _body = definition.getBody();
    for (final BodyStatement body : _body) {
      if ((body instanceof varDeclared)) {
        boolean _equals = ((varDeclared)body).getScope().equals("val");
        if (_equals) {
          locals.add(((varSymbol)body));
        }
      }
    }
    EList<FuncParameter> _args = definition.getArgs();
    for (final FuncParameter arg : _args) {
      locals.add(arg);
    }
    return locals;
  }
  
  public boolean isDefinedBefore(final varDeclared declared, final FuncDefinition definition) {
    boolean isFlag = true;
    final String declaredName = declared.getName();
    EList<BodyStatement> _body = definition.getBody();
    for (final BodyStatement body : _body) {
      if ((body instanceof varAssignment)) {
        String targetVarName = "";
        final Terminal lefte = ((varAssignment)body).getLeft();
        if ((lefte instanceof varRef)) {
          targetVarName = ((varRef)lefte).getVarRef().getName();
        } else {
          if ((lefte instanceof arrayRef)) {
            targetVarName = ((arrayRef)lefte).getVarRef().getName();
          }
        }
        boolean _equals = Objects.equal(declaredName, targetVarName);
        if (_equals) {
          int _indexOf = definition.getBody().indexOf(declared);
          int _indexOf_1 = definition.getBody().indexOf(body);
          boolean _lessEqualsThan = (_indexOf <= _indexOf_1);
          if (_lessEqualsThan) {
            int _indexOf_2 = definition.getBody().indexOf(declared);
            String _plus = (Integer.valueOf(_indexOf_2) + " : ");
            int _indexOf_3 = definition.getBody().indexOf(body);
            String _plus_1 = (_plus + Integer.valueOf(_indexOf_3));
            InputOutput.<String>println(_plus_1);
            isFlag = false;
            return isFlag;
          }
        }
      }
    }
    return isFlag;
  }
}
