/**
 * generated by Xtext 2.12.0
 */
package org.xtext.labs.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.xtext.labs.mydsl.BrkStr;
import org.xtext.labs.mydsl.DoWhileExpression;
import org.xtext.labs.mydsl.FuncCall;
import org.xtext.labs.mydsl.FuncDefinition;
import org.xtext.labs.mydsl.FuncParameter;
import org.xtext.labs.mydsl.IfExpression;
import org.xtext.labs.mydsl.MydslPackage;
import org.xtext.labs.mydsl.StdFunction;
import org.xtext.labs.mydsl.StringRef;
import org.xtext.labs.mydsl.Terminal;
import org.xtext.labs.mydsl.arrayDimension;
import org.xtext.labs.mydsl.arrayRef;
import org.xtext.labs.mydsl.numRef;
import org.xtext.labs.mydsl.varAssignment;
import org.xtext.labs.mydsl.varDeclared;
import org.xtext.labs.mydsl.varExpression;
import org.xtext.labs.mydsl.varRef;
import org.xtext.labs.mydsl.varSymbol;
import org.xtext.labs.typing.MydslTypeProvider;
import org.xtext.labs.validation.AbstractMydslValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MydslValidator extends AbstractMydslValidator {
  @Inject
  @Extension
  private MydslTypeProvider _mydslTypeProvider;
  
  public final static String INVALID_NAME = "uppercase_only";
  
  public final static String INVALID_DUPLICATE = "is_duplicate";
  
  public final static String INVALID_FUNCTION_DUPLICATE = "is_fucntion_duplicate";
  
  public final static String INVALID_BREAK = "not_valid_break";
  
  public final static String INVALID_TYPES = "not_valid_type";
  
  /**
   * @comment:kim
   * this is not best implementation, need to improving
   */
  @Check
  public void checkBreakStr(final BrkStr brk) {
    boolean isTarget = true;
    EObject _eContainer = brk.eContainer();
    if ((_eContainer instanceof IfExpression)) {
      isTarget = false;
    }
    if (isTarget) {
      this.error("The Break Statement is not inside If condition.", MydslPackage.Literals.BRK_STR__BRK, MydslValidator.INVALID_BREAK);
    }
  }
  
  @Check
  public void checkDuplicateVar(final varDeclared check) {
    int mapping_cnt = 0;
    EList<EObject> _eContents = check.eContainer().eContents();
    for (final EObject itemto : _eContents) {
      if ((itemto instanceof varDeclared)) {
        boolean _equalsIgnoreCase = check.getName().equalsIgnoreCase(((varDeclared)itemto).getName());
        if (_equalsIgnoreCase) {
          int _mapping_cnt = mapping_cnt;
          mapping_cnt = (_mapping_cnt + 1);
        }
      }
    }
    if ((mapping_cnt > 1)) {
      this.error("The Variable must be not duplicated.", MydslPackage.Literals.VAR_SYMBOL__NAME, MydslValidator.INVALID_DUPLICATE);
    }
  }
  
  @Check
  public void checkDuplicateFuncName(final FuncDefinition check) {
    int mapping_cnt = 0;
    EList<EObject> _eContents = check.eContainer().eContents();
    for (final EObject itemto : _eContents) {
      if ((itemto instanceof FuncDefinition)) {
        boolean _equalsIgnoreCase = check.getName().equalsIgnoreCase(((FuncDefinition)itemto).getName());
        if (_equalsIgnoreCase) {
          int _mapping_cnt = mapping_cnt;
          mapping_cnt = (_mapping_cnt + 1);
        }
      }
    }
    if ((mapping_cnt > 1)) {
      this.error("The Function name must be not duplicated.", MydslPackage.Literals.FUNC_DEFINITION__NAME, 
        MydslValidator.INVALID_FUNCTION_DUPLICATE);
    }
  }
  
  @Check
  public void checkCompatibleTypes(final varExpression exp) {
    final String actualType = this._mydslTypeProvider.typeFor(exp);
    final String expectedType = this._mydslTypeProvider.expectedType(exp);
    if (((expectedType == null) || (actualType == null))) {
      return;
    }
    boolean _isConformant = this._mydslTypeProvider.isConformant(actualType, expectedType);
    boolean _not = (!_isConformant);
    if (_not) {
      this.error((("Incompatible types. This variable could not assign to " + expectedType) + " Type."), null, 
        MydslValidator.INVALID_TYPES);
    }
  }
  
  @Check
  public void oper_ifOrLoopcheck(final varAssignment vas) {
    boolean isConditionOp = false;
    boolean isTarget = false;
    if (((vas.eContainer() instanceof IfExpression) || (vas.eContainer() instanceof DoWhileExpression))) {
      if ((vas.eContainingFeature().getName().equals("ifconditon") || 
        vas.eContainingFeature().getName().equals("loopConditon"))) {
        isTarget = true;
        EList<String> _op = vas.getOp();
        for (final String op : _op) {
          if ((((((((op.equals(">=") || op.equals("<=")) || op.equals("==")) || op.equals("!=")) || op.equals("<")) || 
            op.equals(">")) || op.equals("and")) || op.equals("or"))) {
            isConditionOp = true;
            return;
          }
        }
      }
    }
    if ((isTarget && (!isConditionOp))) {
      this.error("Incompatible Operation. The operation should be condition.(>=,<=,==,!=,<,>)", null);
    }
    int _size = vas.getOp().size();
    boolean _greaterThan = (_size > 2);
    if (_greaterThan) {
      this.error("Not allowed multiple operation in Right Assignment", null);
    }
  }
  
  @Check
  public void checkArrayInDataArea(final arrayDimension ar) {
    EObject _eContainer = ar.eContainer();
    if ((_eContainer instanceof varDeclared)) {
      varSymbol _index = ar.getIndex();
      boolean _tripleNotEquals = (_index != null);
      if (_tripleNotEquals) {
        this.error("Array Index should be NUM.", null);
      }
      Integer _valueOf = Integer.valueOf(Integer.valueOf(ar.getSize()).intValue());
      boolean _lessThan = ((_valueOf).intValue() < 1);
      if (_lessThan) {
        this.error("Array Size should be more than number 1.", null);
      }
    }
  }
  
  @Check
  public void checkArrayDimension(final arrayRef ar) {
    final varSymbol arRef = ar.getVarRef();
    int arlen = 0;
    if ((arRef instanceof varDeclared)) {
      arlen = ((Object[])Conversions.unwrapArray(((varDeclared)arRef).getDim(), Object.class)).length;
    }
    if ((arRef instanceof FuncParameter)) {
      arlen = ((Object[])Conversions.unwrapArray(ar.getDim(), Object.class)).length;
    }
    int _length = ((Object[])Conversions.unwrapArray(ar.getDim(), Object.class)).length;
    boolean _notEquals = (_length != arlen);
    if (_notEquals) {
      final int size = arlen;
      String _string = Integer.valueOf(size).toString();
      String _plus = ("Array Dimension Size is Incompatible. Dimension Size is " + _string);
      String _plus_1 = (_plus + ".");
      this.error(_plus_1, null);
    }
    int _size = ar.getDim().size();
    boolean _lessThan = (_size < 1);
    if (_lessThan) {
      this.error("Array Size should be more than number 1.", null);
    }
  }
  
  @Check
  public void checkStdFuctionArgSize(final StdFunction std) {
    final int args = ((Object[])Conversions.unwrapArray(std.getArgs(), Object.class)).length;
    final String dfi = this.getStdDefinition(std.getName());
    final int defargs = ((List<Character>)Conversions.doWrapArray(dfi.toCharArray())).size();
    if ((defargs != args)) {
      String _string = Integer.valueOf(defargs).toString();
      String _plus = ("Standard Function arguments size is incompatible. \nThe arguments size is " + _string);
      String _plus_1 = (_plus + ".");
      this.error(_plus_1, 
        null);
    } else {
      final String errormsg = this.stdArgsTypeCompare(std.getArgs(), dfi);
      boolean _isEmpty = errormsg.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        this.error(("Standard Function arguments type is incompatible.\n" + errormsg), null);
      }
    }
  }
  
  public String stdArgsTypeCompare(final EList<Terminal> inputarg, final String dfi) {
    final char[] dfarr = dfi.toCharArray();
    StringBuilder errormsg = new StringBuilder();
    int i = 0;
    for (final char ia : dfarr) {
      {
        String type = "";
        String _string = Character.valueOf(ia).toString();
        if (_string != null) {
          switch (_string) {
            case "N":
              type = "num";
              break;
            case "S":
              type = "string";
              break;
            case "O":
              type = "number or string or bool";
              break;
          }
        }
        final Terminal itm = inputarg.get(i);
        final String tyitm = this.typeReturn(itm);
        boolean _equals = type.toString().equals(tyitm);
        boolean _not = (!_equals);
        if (_not) {
          boolean _not_1 = (!(Objects.equal(type.toString(), "O") && tyitm.contains("num")));
          if (_not_1) {
            boolean _containsDigit = this.containsDigit(type.toString(), tyitm);
            boolean _equals_1 = (_containsDigit == false);
            if (_equals_1) {
              boolean _equals_2 = type.equals("O");
              if (_equals_2) {
                type = "Number or String or Bool";
              }
              String _string_1 = Integer.valueOf((i + 1)).toString();
              String _plus = (_string_1 + ": ");
              String _plus_1 = (_plus + type);
              String _plus_2 = (_plus_1 + "\n");
              errormsg.append(_plus_2);
            }
          }
        }
        int _i = i;
        i = (_i + 1);
      }
    }
    return errormsg.toString();
  }
  
  public boolean containsDigit(final String a, final String b) {
    boolean hasDigit = false;
    if ((a.equals("num") && b.equals("num"))) {
      hasDigit = true;
    }
    return hasDigit;
  }
  
  @Check
  public void checkFuncArgSize(final FuncCall sub) {
    final int args = ((Object[])Conversions.unwrapArray(sub.getArgs(), Object.class)).length;
    int sizearg = sub.getFunc().getArgs().size();
    final FuncDefinition sf = sub.getFunc();
    if ((sizearg != args)) {
      String _string = Integer.valueOf(sizearg).toString();
      String _plus = ("function arguments size is incompatible. function\'s arguments size is " + _string);
      String _plus_1 = (_plus + ".");
      this.error(_plus_1, null);
    } else {
      final String errormsg = this.argsTypeCompare(sf, sub.getArgs());
      boolean _isEmpty = errormsg.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        this.error(("function arguments type is incompatible.\n" + errormsg), null);
      }
    }
  }
  
  public String argsTypeCompare(final FuncDefinition defarg, final EList<Terminal> callarg) {
    StringBuilder errormsg = new StringBuilder();
    final EList<FuncParameter> dg = defarg.getArgs();
    for (final FuncParameter item : dg) {
      {
        if ((item instanceof arrayRef)) {
          final int i = dg.indexOf(item);
          String _type = ((arrayRef)item).getVarRef().getType();
          String _typeReturn = this.typeReturn(callarg.get(i));
          boolean _notEquals = (!Objects.equal(_type, _typeReturn));
          if (_notEquals) {
            boolean _containsDigit = this.containsDigit(((arrayRef)item).getVarRef().getType(), this.typeReturn(callarg.get(i)));
            boolean _equals = (_containsDigit == false);
            if (_equals) {
              String _string = Integer.valueOf((i + 1)).toString();
              String _plus = (_string + ": ");
              String _string_1 = item.toString();
              String _plus_1 = (_plus + _string_1);
              String _plus_2 = (_plus_1 + "\n");
              errormsg.append(_plus_2);
            }
          }
        }
        if ((item instanceof varRef)) {
          final int i_1 = dg.indexOf(item);
          String _type_1 = ((varRef)item).getVarRef().getType();
          String _typeReturn_1 = this.typeReturn(callarg.get(i_1));
          boolean _notEquals_1 = (!Objects.equal(_type_1, _typeReturn_1));
          if (_notEquals_1) {
            boolean _containsDigit_1 = this.containsDigit(((varRef)item).getVarRef().getType(), this.typeReturn(callarg.get(i_1)));
            boolean _equals_1 = (_containsDigit_1 == false);
            if (_equals_1) {
              String _string_2 = Integer.valueOf((i_1 + 1)).toString();
              String _plus_3 = (_string_2 + ": ");
              String _string_3 = item.toString();
              String _plus_4 = (_plus_3 + _string_3);
              String _plus_5 = (_plus_4 + "\n");
              errormsg.append(_plus_5);
            }
          }
        }
      }
    }
    return errormsg.toString();
  }
  
  public String typeReturn(final Terminal t) {
    String rtn = "";
    boolean _matched = false;
    if (t instanceof numRef) {
      _matched=true;
      rtn = "num";
    }
    if (!_matched) {
      if (t instanceof StringRef) {
        _matched=true;
        rtn = "string";
      }
    }
    if (!_matched) {
      if (t instanceof arrayRef) {
        _matched=true;
        varSymbol _varRef = ((arrayRef)t).getVarRef();
        String _type = null;
        if (_varRef!=null) {
          _type=_varRef.getType();
        }
        rtn = _type;
      }
    }
    if (!_matched) {
      if (t instanceof varRef) {
        _matched=true;
        varSymbol _varRef = ((varRef)t).getVarRef();
        String _type = null;
        if (_varRef!=null) {
          _type=_varRef.getType();
        }
        rtn = _type;
      }
    }
    return rtn;
  }
  
  public boolean tryParseInt(final String value) {
    try {
      Integer.parseInt(value);
      return true;
    } catch (final Throwable _t) {
      if (_t instanceof NumberFormatException) {
        final NumberFormatException e = (NumberFormatException)_t;
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public String getStdDefinition(final String d) {
    String buff = "";
    if (d != null) {
      switch (d) {
        case "printstr":
          buff = "S";
          break;
        case "strjoin":
          buff = "SS";
          break;
        case "strsplit":
          buff = "SS";
          break;
        case "numtostr":
          buff = "N";
          break;
        case "equals":
          buff = "OO";
          break;
        case "getargs":
          buff = "N";
          break;
      }
    }
    return buff;
  }
}
